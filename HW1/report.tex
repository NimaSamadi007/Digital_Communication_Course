\documentclass[a4paper]{article}

\usepackage{geometry}
\usepackage{amsfonts, amssymb, amsmath, mathrsfs}
\usepackage{graphicx, hyphenat, enumerate, float, mathtools}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepackage{titlesec, parskip, setspace}
\titlespacing{\section}{0pt}{10pt}{0pt}
\titlespacing{\subsection}{0pt}{10pt}{0pt}
\titlespacing{\subsubsection}{0pt}{10pt}{0pt}
\renewcommand{\baselinestretch}{1.4}
\usepackage[pagebackref=false,colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{fvextra}
\usepackage{tabularx}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{تمرین سری 1}
\fancyhead[R]{سیستم‌های دیجیتال}
\fancyfoot[C]{\thepage}


\usepackage[fontsloadable]{xepersian} 
\settextfont{HM XNiloofar}
\setdigitfont{HM XNiloofar}
\DefaultMathsDigits

\makeatletter
\bidi@patchcmd{\@Abjad}{آ}{الف}
{\typeout{Succeeded in changing `آ` into `الف`}}
{\typeout{Failed in changing `آ` into `الف`}}
\makeatother
\PersianAlphs

\renewcommand{\tabularxcolumn}[1]{>{\small}m{#1}}

\begin{document}
\begin{center}
\begin{bf}
\huge{به نام خدا} \\
\vspace*{3mm}
\large{مخابرات دیجیتال}\\
\vspace*{1.5mm}
\large{استاد بهنیا} \\
\vspace*{1.5mm}
\large{تمرین سری  1} \\
\vspace*{1.5mm}
\large{نیما صمدی - 97102011} \\
\vspace*{1.5mm}
\today \\
\vspace*{1.5mm}
\line(1,0){400}
\vspace*{5mm}
\end{bf}
\end{center}
\section{سوال اول}
ابتدا مطابق توضیحات صورت سوال، توابع 
\lr{MyHuffman.m}
و
\lr{MyLempelZiv.m}
را نوشتم. این تابع با کامنت‌گذاری مناسب و به صورت توابع مستقل از هم نوشته شده است تا قابلیت استفادۀ مجدد داشته باشد و فهم آن راحت باشد. 

\begin{enumerate}[1)]
\item نرخ فشرده‌سازی بسته به تعداد سمبل‌ها متفاوت است و تغییر می‌کند. در اینجا خروجی یکی از دفعات اجرای کد دیده می‌شود:
\begin{latin}
\begin{Verbatim}[frame=single,
				baselinestretch=1.2,
				xleftmargin=1.5cm,
				xrightmargin=1.5cm,
				breaklines=true]
Matlab Huffman coding compresion
    1.3683
Avg lenght: 8770

My Huffman coding compresion
    1.3683
Avg lenght: 8770

Lempel-Ziv coding compresion rate
    0.9494
Avg lenght: 12640
\end{Verbatim}
\end{latin}
میزان فشرده‌سازی برای 3 حالت بیان شده است. خروجی اول از توابع متلب برای کدگذاری هافمن است. خروجی دوم نتیجۀ فشرده‌سازی تابع 
\lr{MyHuffman.m}
و خروجی آخر نتیجۀ تابع
\lr{MyLempelZiv.m}
است. البته در برخی مواقع نتیجۀ کدگذاری 
\lr{Huffman}
تابع من و متلب اندکی با هم تفاوت دارد. به نظر من این به خاطر نحوۀ نسبت دادن کدها می‌باشد. من هر بار دو سمبل با کمترین احتمال را انتخاب می‌کنم و آنها را ترکیب می‌کنم. سپس دوباره سمبل‌ها را مرتب کرده و این روند را ادامه می‌دهم. اما به نظر متلب به نحوۀ دیگری این کار را انجام می‌دهد. به همین خاطر کد‌های نسبت‌داده شده با هم تفاوت دارند هر چند این تفاوت در حد چند بیت است و گاهی نتیجۀ حاصل از کد من از روش متلب بهتر است و برعکس. \\
همانطور که دیده می‌شود، میزان فشرده‌سازی کد هافمن من و متلب برابر 
$1.3713$
است. میزان فشرده‌سازی کد 
\lr{Lempel-Ziv}
نیز برابر 
$0.9542$
است. برای کد 
\lr{Lempel-Ziv}
برای نمایش اعداد سمبل‌ها نیاز به تعدادی بیت است. تعیین کردن این تعداد بیت‌ها از روی حداکثر شمارۀ سمبل در رشتۀ کد شده بدست می‌آید. تعداد کدها 
$756$
تا بود که برای نمایش این تعداد نیاز به حداکثر 
$10$
بیت است. البته ممکن است کمتر از این عدد مورد نیاز باشد. به همین خاطر تابع
\lr{MyLempelZiv.m}
علاوه بر رشتۀ کدشده، بیشینۀ بیت‌های لازم برای نمایش عدد کنار هر سمبل را نیز خروجی می‌دهد. البته در عمدۀ تعداد اجراها این عدد 
$10$
بود.
\item در مورد کدگذاری 
\lr{Lempel-Ziv}
صرفا دانستن طول بیت عدد کنار هر سمبل در رشتۀ کدشده کافی است. برای 
$2000$
کاراکتر تولیدی، باید 
$10$
بیت برای آدرس جدا کرد. همچنین هر سمبل نیز با 6 بیت نمایش داده می‌شود. بنابراین با دانستن این دو عدد و بدون اطلاعات دیگری می‌توان رشتۀ دریافتی را دیکود کرد. البته باید درخت متناظر را ساخت که برای هر سمبل کدشده، حداکثر 
$16$
بیت لازم است. \\
برای کد هافمن این تعداد اعضای دیکشنری بستگی به توزیع دارد. اگر رشتۀ تصادفی کاملا از همان توزیع ورودی پیروی کند میزان بیت لازم برای دیکشنری هافمن ثابت خواهد بود. برای چندین اجرایی که انجام دادم به نظر این فرض صحیح است. میزان تعداد بیت لازم برای نمایش دیکشنری برابر 
$197 \, \mathrm{bits}$
می‌باشد. با اجرای کد سوال اول این مقدار در خروجی نوشته می‌شود. بنابراین اگر در گیرنده، 
$197$
بیت را به ترتیب داشته باشیم، می‌توانیم کل رشتۀ دریافتی را بازسازی کنیم.
\item مطابق مباحث درس، می‌دانیم در صورتی که احتمال وقوع هر سمبل به صورت توانی از 
$\frac{1}{2}$
باشد، کد هافمن بهینه می‌شود و می‌تواند حد فشرده‌سازی به اندازۀ آنتروپی منبع داشته باشد. بنابراین اگر توزیع احتمال به صورت توان‌هایی از 
$\frac{1}{2}$
تغییر کند، میزان فشرده سازی بیشینه می‌شود. بنابراین توزیع احتمال باید به صورت زیر شود:
\begin{align*}
P_X(i) = 
\begin{cases}
(\dfrac{1}{2})^i & i = 1, 2, \cdots, 32 \\[10pt]
(\dfrac{1}{2})^{32} & i = 33 \\[10pt]
0 & \mathrm{O.W.}
\end{cases}
\end{align*}
می‌توانید مشاهده کنید که در این حالت جمع احتمال‌ها 
$1$
است پس توزیع احتمال معتبری است. اگر آنتروپی را برای این توزیع احتمال حساب کنید:
$$
H_X = 2 \, (\mathrm{\frac{bits}{symbol}})
$$
اگر کد هافمن را استفاده کنیم، می‌توانیم به جای 
$6$
بیت برای هر سمبل، به میزان فشرده‌سازی 
$2$
بیت برای هر سمبل برسیم. یعنی میزان فشرده‌سازی برابر
$3$
خواهد شد. البته این محاسبات از نظر تئوری صحیح است. اما در موقع پیاده‌سازی نتیجۀ متلب می‌تواند متفاوت باشد. علت این است که متغیر‌های تصادفی در کامپیوتر، کاملا تصادفی نیستند. بنابراین توزیع احتمالی که بدست می‌آید کاملا منطبق بر این توزیعی که بیان کردم نیست. \\
نتیجۀ حاصل از متلب برای این توزیع احتمال منبع به صورت زیر است:
\begin{latin}
\begin{Verbatim}[frame=single,
				baselinestretch=1.2,
				xleftmargin=1.5cm,
				xrightmargin=1.5cm,
				breaklines=true]
Matlab Huffman coding compresion
    2.9903
Avg lenght: 4013

My Huffman coding compresion
    2.9903
Avg lenght: 4013

Lempel-Ziv coding compresion rate
    1.7354
Avg lenght: 6915
\end{Verbatim}
\end{latin}
البته گاهی میزان فشرده‌سازی عددی بیشتر از 
$3$
می‌شود که به خاطر خطای محاسبات است. همانطور که دیده می‌شود نتیجۀ حاصل از کدینگ هافمن بسیار بهتر است. علت این موضوع بهینه‌بودن کدینگ هافمن نسبت به سایر کدینگ‌ها، از جمله 
\lr{Lempel-Ziv}
است.
\item مشابه کاری که در بخش قبل انجام دادم اینجا عمل می‌کنم. البته در اینجا ابتدا توزیع احتمال رشتۀ ورودی را پیدا می‌کنم. در بررسی متن داده شده متوجه شدم که مقادیر سمبل‌ها از 
$32$
تا
$121$
عوض می‌شود. بنابراین تعداد کل سمبل‌ها 
$99$
تا است. البته تعدادی از این سمبل‌ها اصلا رخ نمی‌دهند و احتمال صفر دارند اما در فرایند کد هافمن و 
\lr{Lempel-Ziv}
مشکلی ایجاد نمی‌کنند. توابعی که من نوشتم، در آنها فرض شده که تعداد رقم تمام سمبل‌ها یکسان است. مثلا تمام سمبل‌ها عدد دو رقمی هستند. به همین خاطر صرفا برای انجام کدینگ، ابتدا سمبل‌ها را در فایل 
\lr{file2.txt}
را به محدودۀ 
$[100, 188]$
مپ می‌کنم. توجه کنید که این کار هیچ تاثیری در کدگذاری ندارد و صرفا برای این انجام شده است که تغییری در توابع انجام ندهم. برای دیکود کردن صرفا کافی است یک 
\lr{mapping}
(که صرفا یک شیفت است) را انجام دهیم. پس از 
\lr{mapping}، 
احتمال رخداد هر سمبل را با تابع 
\lr{CalDist.m}
محاسبه می‌کنم. در نهایت سمبل‌ها و توزیع آنها را به توابع محاسبۀ کدینگ هافمن و 
\lr{Lempel-Ziv}
ارسال می‌کنم و نتایج را در اینجا بیان می‌کنم. توجه کنید که دوباره برای مقایسۀ نتیجۀ هافمن، از خود توابع متلب نیز جداگانه استفاده کرده‌ام تا نتایج را با هم مقایسه کنم.
\begin{latin}
\begin{Verbatim}[frame=single,
				baselinestretch=1.2,
				xleftmargin=1.5cm,
				xrightmargin=1.5cm,
				breaklines=true]
Matlab Huffman coding compresion
    1.4121
Avg lenght: 19860

My Huffman coding compresion
    1.4121
Avg lenght: 19860

Lempel-Ziv coding compresion rate
    1.1775
Avg lenght: 23817
\end{Verbatim}
\end{latin}
همانطور که دیده می‌شود، نتیجۀ هافمن متلب و تابع خودم کاملا یکسان است. \\
همانطور که از مقایسۀ نرخ فشرده‌سازی دیده می‌شود، کدینگ هافمن عملکرد بهتری دارد. علت آن بهینه بودن این روش کدینگ است. به علاوه در روش 
\lr{Lempel-Ziv}
مزیت اصلی عدم نیاز به محاسبۀ توزیع احتمال و ذخیرۀ دیکشنری در سمت گیرنده است. همچنین میزان فشرده‌سازی این روش کدینگ، کاملا به طول رشتۀ ورودی بستگی دارد. به عبارت دیگر هر چقدر طول رشتۀ ورودی بزرگتر شود، این کدینگ بهتر عمل می‌کند چون به جای ارسال سمبل‌های طولانی‌تر، صرفا کافی است یک عدد (معادل آدرس سمبل‌های قبلی) ارسال کنیم که مرتبۀ تعداد بیت این عدد با لگاریتم طول رشته زیاد می‌شود. در حالی که اگر خود رشتۀ ورودی را ارسال کنیم، باید به اندازۀ خود آن بیت استفاده کنیم. پس در واقع یک مقایسه بین رشد تابع لگاریتمی و خطی داریم که برای مقادیر بزرگ، تابع خطی بسیار بزرگتر از لگاریتم می‌شود و این ایدۀ اصلی روش 
\lr{Lempel-Ziv}
است.
\end{enumerate}
\section{سوال دوم}

\end{document}